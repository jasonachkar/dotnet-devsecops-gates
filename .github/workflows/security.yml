# =============================================================================
# security.yml — Security Scanning Workflow (GitHub Actions)
# =============================================================================
# This workflow runs three independent security scanning jobs:
#
#   1. CodeQL (SAST) — Static Application Security Testing for C#
#      Analyzes source code for vulnerability patterns like SQL injection,
#      open redirects, XSS, insecure deserialization, etc.
#
#   2. Gitleaks — Secrets scanning of the current working tree (dir mode)
#      Detects API keys, tokens, passwords, and custom patterns defined
#      in .gitleaks.toml. Runs in "dir" mode (not git-history mode) to
#      avoid false positives from old commits. SARIF results are uploaded
#      to the GitHub Security tab.
#
#   3. Semgrep — Pattern-based SAST with custom rules
#      Catches vulnerability patterns that CodeQL's dataflow analysis
#      may miss in minimal API lambdas (XSS, open redirects).
#      Custom rules live in .semgrep/demo-rules.yml.
#
#   4. Dependency Review — PR-only check for vulnerable dependencies
#      Compares the dependency diff between the PR and base branch,
#      flagging any newly introduced packages with known CVEs.
#
# All three jobs run independently in parallel for faster feedback.
#
# NOTE: Code Scanning UI and Dependency Review features require the repo
# to be public, or require GitHub Advanced Security for private repos.
# =============================================================================

name: Security

on:
  push:
    branches:
      - main                   # Scan on pushes to main (baseline)
      - 'demo/**'              # Scan on demo branches for portfolio screenshots
  pull_request:
    branches: [main]           # Scan on PRs targeting main
  workflow_dispatch:           # Allow manual triggering

# Permissions explained:
#   contents: read       — needed to checkout code
#   security-events: write — needed for CodeQL to upload SARIF results
#                           to the Security tab (Code scanning alerts)
#   pull-requests: read  — needed for dependency-review-action to read PR diff
permissions:
  contents: read
  security-events: write
  pull-requests: read

jobs:
  # ===========================================================================
  # Job 1: CodeQL — Static Application Security Testing (SAST)
  # ===========================================================================
  # CodeQL builds the C# project, creates a database of code flows, and
  # runs security queries against it. Results appear in GitHub Security tab.
  #
  # Using v4 of codeql-action (latest stable).
  # Query suite: security-extended — includes standard security queries plus
  # additional coverage for common vulnerability patterns beyond the defaults.
  codeql:
    name: CodeQL Analysis
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v6

      # Initialize CodeQL — sets up the analysis database for C#.
      # This must run BEFORE the build step so CodeQL can intercept
      # the compilation and capture code flow information.
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v4
        with:
          languages: csharp
          queries: security-extended    # Broader coverage than default

      # Autobuild — lets CodeQL detect and build the .NET project automatically.
      # For .NET projects, it runs `dotnet build` under the hood.
      # Using autobuild instead of manual build for simplicity and reliability.
      - name: Autobuild
        uses: github/codeql-action/autobuild@v4

      # Analyze — runs the security queries and uploads SARIF results.
      # Results appear in: GitHub repo > Security tab > Code scanning alerts.
      # On PRs, alerts also appear as inline annotations on changed files.
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v4
        with:
          category: codeql
          output: codeql-results

      # Branch-aware CodeQL gate.
      # - Fails closed if no SARIF files exist (safe default).
      # - Demo branches (demo/*): fail on ANY finding regardless of severity.
      # - Other branches (main, etc.): fail only on High/Critical findings
      #   (security-severity >= 7.0 in SARIF rule metadata).
      #
      # We parse security-severity from rule properties instead of relying
      # on SARIF .level, because CodeQL marks most security findings as
      # level "warning" even when they are High/Critical severity.
      - name: Enforce CodeQL gate
        env:
          REF_NAME: ${{ github.ref_name }}
          HEAD_REF: ${{ github.head_ref }}
        run: |
          set -euo pipefail
          source_branch="${HEAD_REF:-$REF_NAME}"

          shopt -s nullglob
          sarif_files=(codeql-results/*.sarif)

          if [ "${#sarif_files[@]}" -eq 0 ]; then
            echo "::error::No SARIF files found in codeql-results; cannot evaluate CodeQL gate"
            exit 1
          fi

          total_results=0
          high_or_critical_results=0

          for f in "${sarif_files[@]}"; do
            file_total=$(jq '[.runs[]?.results[]?] | length' "$f")

            file_high=$(jq '
              [
                .runs[]? as $run
                | (
                    reduce (
                      [ $run.tool.driver.rules[]?, $run.tool.extensions[]?.rules[]? ][]?
                    ) as $rule ({}; .[$rule.id] = (($rule.properties["security-severity"] // "0") | tonumber? // 0))
                  ) as $rule_severity
                | $run.results[]?
                | ($rule_severity[.ruleId] // 0) as $security_severity
                | select($security_severity >= 7.0)
              ]
              | length
            ' "$f")

            total_results=$((total_results + file_total))
            high_or_critical_results=$((high_or_critical_results + file_high))
          done

          echo "Source branch: $source_branch"
          echo "CodeQL total results: $total_results"
          echo "CodeQL high/critical results: $high_or_critical_results"

          if [[ "$source_branch" == demo/* ]]; then
            if [ "$total_results" -gt 0 ]; then
              echo "::error::CodeQL found $total_results finding(s) on demo branch '$source_branch'"
              exit 1
            fi
            echo "No CodeQL findings on demo branch '$source_branch'"
            exit 0
          fi

          if [ "$high_or_critical_results" -gt 0 ]; then
            echo "::error::CodeQL found $high_or_critical_results high/critical finding(s) on branch '$source_branch'"
            exit 1
          fi

          echo "No high/critical CodeQL findings on branch '$source_branch'"

  # ===========================================================================
  # Job 2: Gitleaks — Secrets Scanning (dir mode)
  # ===========================================================================
  # Scans the CURRENT WORKING TREE (not git history) for leaked secrets.
  # Uses "dir" mode instead of "git" mode to avoid false positives from
  # old commits that may have contained demo patterns.
  #
  # Custom rules are defined in .gitleaks.toml at the repo root.
  # The demo rule detects lines starting with the demo token followed
  # by an equals sign — only fires on actual leak files, not prose.
  #
  # Pattern:
  #   1. Run gitleaks with continue-on-error (so SARIF uploads even on findings)
  #   2. Upload SARIF to GitHub Security tab (always)
  #   3. Fail the job if gitleaks found leaks (check step outcome)
  #
  # No license key needed — uses the official container image directly.
  gitleaks:
    name: Secrets Scanning
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v6

      # Run gitleaks in "dir" mode — scans working tree only (no git history).
      # Pinned to a specific container tag for reproducibility.
      # --report-format sarif outputs results for GitHub Security tab.
      # continue-on-error: true ensures the SARIF upload step runs even
      # when leaks are found (gitleaks exits non-zero on findings).
      - name: Run Gitleaks
        id: gitleaks
        continue-on-error: true
        run: |
          docker run --rm \
            -v "${{ github.workspace }}:/repo" \
            -w /repo \
            ghcr.io/gitleaks/gitleaks:v8.22.1 \
            dir --config .gitleaks.toml \
                --report-format sarif \
                --report-path gitleaks.sarif \
                .

      # Upload SARIF results to GitHub Security > Code scanning alerts.
      # Runs on success AND failure so findings are always visible in the UI.
      # Uses codeql-action/upload-sarif (same as CodeQL) — the Security tab
      # aggregates results from all SARIF sources.
      - name: Upload Gitleaks SARIF
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: gitleaks.sarif
          category: gitleaks

      # Fail the job if gitleaks detected leaks.
      # The gitleaks step uses continue-on-error so SARIF uploads first,
      # but we still want the overall job to fail for PR status checks.
      - name: Fail on leaks
        if: steps.gitleaks.outcome == 'failure'
        run: |
          echo "::error::Gitleaks detected secrets in the working tree"
          exit 1

  # ===========================================================================
  # Job 3: Semgrep — Pattern-based SAST (custom rules)
  # ===========================================================================
  # Semgrep uses AST pattern matching (not dataflow) so it reliably catches
  # vulnerability patterns in minimal API lambdas where CodeQL's C# taint
  # analysis has limited coverage.
  #
  # Custom rules in .semgrep/demo-rules.yml detect:
  #   - Reflected XSS via Response.WriteAsync with unencoded user input
  #   - Open redirect via Response.Redirect with unvalidated user input
  #
  # Uses the returntocorp/semgrep-action GitHub Action which:
  #   1. Installs Semgrep CLI
  #   2. Runs the specified rules against the codebase
  #   3. Outputs SARIF for upload to the GitHub Security tab
  #
  # The job uses the same branch-aware gate pattern as CodeQL:
  #   - Demo branches: fail on ANY finding
  #   - Other branches: fail only on error-level findings
  semgrep:
    name: Semgrep Analysis
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v6

      - name: Install Semgrep
        run: pip install semgrep

      # Run Semgrep with custom rules from .semgrep/ directory.
      # --sarif outputs results in SARIF format for the Security tab.
      # --error exits non-zero if findings exist (used for gate logic).
      # continue-on-error: true so SARIF uploads even when findings exist.
      - name: Run Semgrep
        id: semgrep
        continue-on-error: true
        run: |
          semgrep scan \
            --config .semgrep/ \
            --error \
            --sarif \
            --output semgrep.sarif \
            src/

      # Upload SARIF to GitHub Security > Code scanning alerts.
      # Runs always so findings appear in Security tab even on failure.
      - name: Upload Semgrep SARIF
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: semgrep.sarif
          category: semgrep

      # Fail the job if Semgrep found issues.
      - name: Fail on findings
        if: steps.semgrep.outcome == 'failure'
        run: |
          echo "::error::Semgrep found security findings in the codebase"
          exit 1

  # ===========================================================================
  # Job 4: Dependency Review — PR-only vulnerability check
  # ===========================================================================
  # Only runs on pull requests (not pushes).
  # Compares the dependency graph before and after the PR changes.
  # Flags any newly introduced packages with known vulnerabilities (CVEs).
  #
  # This is complementary to the vulnerability check in ci.yml:
  #   - ci.yml checks ALL current dependencies every run
  #   - This job checks only NEWLY ADDED dependencies in the PR diff
  #
  # Requires the repo to be public or have GitHub Advanced Security enabled.
  dependency-review:
    name: Dependency Review
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'    # Only run on PRs, not pushes

    steps:
      - uses: actions/checkout@v6

      # Analyze dependency changes introduced by this PR.
      # Fails if any new dependency has a known High or Critical vulnerability.
      - name: Dependency Review
        uses: actions/dependency-review-action@v4
        with:
          fail-on-severity: high
